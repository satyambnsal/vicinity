{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":5362380431978757331,"abi":{"parameters":[{"name":"user_lat","type":{"kind":"field"},"visibility":"private"},{"name":"user_lon","type":{"kind":"field"},"visibility":"private"},{"name":"landmark_lat","type":{"kind":"field"},"visibility":"public"},{"name":"landmark_lon","type":{"kind":"field"},"visibility":"public"},{"name":"max_distance","type":{"kind":"field"},"visibility":"public"},{"name":"partial_data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":256,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"partial_hash","type":{"kind":"array","length":8,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"private"},{"name":"full_data_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"public"},{"name":"redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5634341720269277520":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"5675127253506927136":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6314603625877298116":{"error_kind":"string","string":"haystack length of size 0 not supported"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6543056410826478903":{"error_kind":"string","string":"incorrect value for claim"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7788270038095378938":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"9810871316194602178":{"error_kind":"string","string":"User is too far from the landmark"},"13815800804469369678":{"error_kind":"string","string":"partial_data length is too long"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"15412340888643424233":{"error_kind":"string","string":"needle length of size 0 not supported"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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2myqrM2musQpG+bMzqZ6dpyZnU2F5Evf183kbCooX/qEOZOzqaB87alLzqaC8rWnLjmbCsqXPmHO2myqrM2mytpsqizEprozzOxsKuA42dlUSL70CXMmZ1NB+dxTF8qXPmHO5GwqtO+Ts6mgfO2pq82mytpsqqzNpsrabKosxKa6lc89dZFh1mZTZXI2FZSvfcKszabK2myqTM6mgvK1p642myprs6myNpsqa7OpshCb6la+Tta9s2zabKpMzqZC8rXZVFmbTZW12VSZnE0F5WtPXW02VdZmU2VtNlXWZlNlITbVnedhZ1MB08DOpkLytacuOZsKyueeulC+9n1dcjYV2vfJ2VRQvvbU1WZTZW02VdZmU2UhNtWdZWNnUwHPw86mQvK1py45mwrK176vq82myuRsKrTvk7OpoHztqavNpsrabKqszabK2myqrM2mykJsqjvDzM6mAo6TnU0F5JOzqZDnIWdTQfnaJ8zabKpMzqZC+z45mwrK15662myqrM2mykJsqhvPU9jZVM+mobCzqZB86albyNlUUD731IXypU+YCzub6nnfL+RsKihfeuoWcjYVkk/OpoLypU+YixCb6s6ysbOpgOdhZ1Mh+dpTl5xNBeVL39ct5GwqKF976rKzqZB87alLzqaC8qXv6xZyNhWUL/2lv8LOpgKeh51NheRrT11yNhWST86mgvKl7+sWbTZV0WZTFSE21a186fu6hZ1NheRrnzCTs6mQZSNnUyHPQ86mgvK1py45mwrK176vS86mgvK1p642m6oIsalu5Wvf12VnUwH55GwqKF/7hJmcTYUcJzmbClk2djYVkq99X5ecTQXla9/XJWdTQfnaU5edTYXka09dcjYVlK99wkzOpoLytbOuEJvqznGys6mAZWNnUyH52vd1ydlUUL72CTM5mwrK15667GwqJF976pKzqaB87RNmcjYVlK/9vi47mwp4HnY2FZKvPXXJ2VRQPvfUhfK1T5i12VRFiE11K1976rKzqYB8cjYVlK99wkzOpoLydbLuneNkZ1MBy8bOpkLyte/rkrOpoHzt+7rkbCogv7KzqZ73/crOpkLypaduJWdTQfnkUxfJlz5hrtpsqqrNpqrabKqqzaaqQmyqm7hS2dlUz36/srOpkHzpE+ZKzqaC8qVPmKs2m6qSs6ngvq89dbXZVFWbTVW12VRViE11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Pz7/jiKqENtOXdlOPyqbp2Z7RzFVttOPxuap2d5RTI3t9KOxeWq2dxRTYzv9aGyemu0dxdTYTj8am6dme0cxdbbTj87mqdneUUyff0cR/ZOxeWq2dxRTZzv96Gyemu0dxTTYTj8Gm6dme0cxDbbTj8+/o4gqxLZTD7bTj8HmqdneUUyD7fRjsnlqtncU02Q7/ZhsnprtHcU02U4/JpunZntHMU2204/J5qnZ3lFMJ9vpx8nmqdneUUyff0cR/ZOxeWq2dxTTyXb6cbJ5arZ3FPNBdvqRDzJPndneUcwH2enH9Z9jqxDZTp0PstOPfJB56sz2jmI+yE4/8qffUUzH0ea/fn3973EnKfFJynySCp+k+nFJ4/xd0jluJDU+SZ1P0uCTND8tKeX+kpTqeSPppJOUDz5J6auSWruR9PHdO72+Gnr97zPdSCp8kirdQMmNT1LnkzT4JE26gZJPOknl4JOU+CRluhlXCp+kyiep8UnqdOakDDonUCafpJNOUj34JCU+SXwnJ5Xv5KRWPkl83rvyee/K570rn/eufN678Xnvxue9G5/3bnzeu1U+SXzeu/F578bnvRuf92583rvzee/O5707n/fufN67Vz5JfN6783nvzue9O5/37nzee/B578HnvQef9x583ntUPkl83nvwee/B570Hn/cefN578nnvyee9J5/3nnzee1Y+SXzee/J578nnvSef95583vvk894nn/c++bz3yee9z8onic97n3ze++Tz3ief9z7pvHc56Lx3Oei8dznovHc56Lx3Oei8dznovHc56Lx3Oei8dznovHc56Lx3SXTeuyQ6710Snfcuic57l8+/a4kl0Xnvkui8d0l03rskOu9dEp/3znzeO/N578znvTOf9+Z717LwvWtZ+N61LHzvWha+dy0L37uWhe9dy8L3rmXhe9ey8L1rWfjetSx871oWvnctC9+7loXvXcvC965l4XvXsvC9a1k+/65lLuklKd9tAp9/1xJLqnySGp+kzidp8En6+O6dZ3lJuu4E/EnSX3/f5vGvX7fzJjp8/r3MpfI//w7nWvlJW37Wll+05Vdt+U1bfteWP7Tla0/dpj11u/bU7dpTt2tP3a49dT//rvBa+dpTt2tP3a49dbv21O3aU3doT92hPXWH9tQd2lP38+94r5WvPXWH9tQd2lN3aE/doT11p/bUndpTd2pP3ak9dT//bv5a+dpTd2pP3ak9daf21J3aU/fUnrqn9tQ9tafuqT11P89UWCtfe+qe2lP31J66p/bUPaWnbj2kp249pKduPaSnbj2kp249pKduPaSnbj2kp249pKduPaSnbj20p27SnrpJe+om7ambtKfu5xkma+VrT92kPXWT9tRN2lM3aU/drD11s/bUzdpTN2tP3c+zZ9bK1566WXvqZu2pm7WnbtaeukV76hbtqVu0p27RnrqfZwatla89dYv21C3aU7doT92iPXWr9tSt2lO3ak/dqj11v8B6Wipfe+pW7albtaeuNpuqarOpqjabqmqzqao2m6pqs6mqNpuqarOpqjabqmqzqao2m6pqs6mqNpuqarOpqjabqmqzqao2m6pqs6mqNpuqarOpqjabqmqzqao2m6pqs6mqNpuqarOpqjabqmqzqao2m6pqs6mqNpuqarOpqjabqmqzqao2m6pqs6mqNpuqarOpqjabqmqzqao2m6pqs6mqNpuqarOp6hfYVP33j+6VlG4kFT5JlU9S45PU+SQNPkmTT9LJJql9gZ0EJX18py9l/C6pzBtJmU/Sx3fvMvJLUi3njaTKJ6nxSep8kgafpMkn6aST9HkGD5aU+CRlPkl8u3fi270T3+6d+HbvxLd7J77dO/Ht3plv9858u3fm270z3+6d+XbvzLd7Z77dO/Pt3plv9858u3fh270L3+5d+Hbvwrd7F77du/Dt3oVv9y58u3fh270L3+5d+Xbvyrd7V77du/Lt3pVv9658u3fl270r3+5d+Xbvyrd7N77du/Ht3o1v9258u3fj270b3+7d+Hbvxrd7N77du/Ht3p1v9+58u3fn27073+7d+Xbvzrd7d77du/Pt3p9/F7ul3x8xvs64bySddJI+/840lpT4JH18977Mx++SZruR9PHdu5f2ktRbuZFU+f7hGp+kzidp8EmafFfcSXfFTb7de/Lt3p9/RxZLKnySKt0V9/n3U/EVx7d7T77de/J578nnvT//Die84j7/Xia84k6+3fvk270//64llsTnvT//riW+4gbfFce3e590u3c/6Lx3P+i8dz/oTk76QXdy0g+63bsfdLt3P+i8dz/ovHc/6E5O+kF3ctIT3+6d+HbvROe9e6Lz3v3z71rCKy7RnZz0xLd7J77dO9F57574vHemOznpme7kpGe+3Tvz7d6ff9cSS+Lz3pnu5KRnupOTnvl278y3exc+7134vHfhOzkpfCcnhW/3Lny7d+Hz3oXPexe+k5PCd3JS+Xbvyrd7Vz7vXfm89+fftYRXXOU7Oal8u3fl270rn/eufN678Z2cNL6Tk8a3eze+3fvz71piSXzeu/GdnDS+k5PGt3s3vt2783nvzue9O9/JSec7Oel8u3fn2707n/fufN67852cdL6TE753LTvfu5Z98Hnvwee9v/CuJbriBt/JCd+7lp3vXcs++Lz34PPek+/kZPKdnPC9a9n53rXsX3jXEkri896T7+Rk8p2c8L1r2fnetewnn/c++bz3yXdycvKdnPC9a9n53rXsJ5/3Pvm898l3cnLSnZwMvnctB9+7luOg897joPPe46hsV9w46E5OBt+7loPvXctx0HnvcdB575HoTk5Gojs5GXzvWg6+dy3HF961hJLovPdIdCcnI9GdnAy+dy0H37uWI/N578znvTPdycnIdCcng+9dy8H3ruXIfN4783nvTHdyMjLfyQnfu5aD713LUfi8d+Hz3l941xJdcYXv5ITvXcvB967lKHzeu/B578p3clL5Tk743rUcfO9aji+8awkl8XnvyndyUvlOTvjetRx871qOxue9G5/3bnwnJ43v5ITvXcvB967laHzeu/F578Z3ctL4Tk743rUcfO9ajs7nvTuf9/7Cu5boiut8Jyd871oOvnctB993LQffdy3H4Ds5GXwnJ3zvWg6+dy0H33ctB993LcfgOzkZfCcnfO9aDr53LQffdy0H33ctx+Q7OZl8Jyd871oOvnctB993LQffdy3H5Ds5mXwnJ3zvWg6+dy0H33ctB993LccX3rVEV9zJd3LC967l4HvXcvB913LwfddyHnQnJ/OgOzmZfO9aTr53LedB570n33ct50F3cjIPupOTyfeu5eR713Lyfddy8n3Xcia6k5OZ6E5OJt+7lpPvXcvJ913Lyfddy5noTk5mojs5mXzvWk6+dy0n33ctJ993LecX3rVEV1ymOzmZfO9aTr53LSffdy0n33ctZ+E7OSl8Jyd871pOvnctJ993LSffdy1n4Ts5KXwnJ3zvWk6+dy0n33ctJ993LWflOzmpfCcnfO9aTr53LSffdy0n33ctZ+U7Oal8Jyd871pOvnctJ993LSffdy3nF961RFdc4zs54XvXcvK9azn5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96yrZeSedbWM3LOuljVquayWkXvW1TJyz7paRu5ZV8vIPetqGblnWS1T5J51tYzcs66WkXvW1TJyz7paVutaQt5YT95hZiVvrCfvMPMLzeadUNY2m3dC+YVm844dS5ste8cO3GzZO0usbTbvLPELzeYdENY2W41me262CAjrmi0CAmi2CAjrmi0CAmi2CAjLmq1EQHhuthIBYV2zRUAAzRYBYV2z1Wi252aLgLCu2SIggGaLgLCu2SIggGaLgLCs2WoEhOdmqxEQ1jVbBATQbBEQ1jVbjWZ7brYICOuaLQICaLYICOuaLQICaLYICMuarUVAeG62FgFhXbNFQADNFgFhXbPVaLbnZouAsK7ZIiCAZouAsK7ZIiCAZouAsKzZegSE52brERDWNVsEBNBsERDWNVuNZntutggI65otAgJotggI65otAgJotggIy5rN/Nv2uNnMP0C/ttkiIIBmi4CwrtlqNNtzs0VAWNdsERBAs0VAWNdsERBAs0VAWNZs5h8Jx81m/uXvtc1mHhBGm69ajjlumu3TAWHm8fMvz9aXF2jM47XgmeafCvTbguteC/6bHZFbenFdr2atNx3RvAt0jleBypEb2H6ugraXntwm+vtgu+pR+6/VfkTtv1b7GbX/Wu3PqP23av/xD4dH7X+vfYraf632OWr/tdpvlvikal+j9l+rfeTa79U+cu33ah+59nu1j1z7vdpHrv1W7ccRufZ7tY9c+73aR679W7Xvrb9qfx0C/7Pae+fay2u8ann1YQK1B7Ws1rVc+fHLcXjnzrW19M6Ra2vpnQvX1tI7562tpXduW1rL5J3D1tbSO1etraV3TlpbS+/cs7aWNWq5rJaRe9bVMnLPulpG7llXy8g962oZuWdZLXPknnW1jNyzrpaRe9bVMnLPulrWqOWyWkbuWVfLyD3rahm5Z10tI/esq2XknmW1LJF71tUycs+6WkbuWVfLyD3ralmjlstqGblnXS0j96yrpXfugbyxUbzDzEre2CjeYQY3W/VOKEubrXonlF9oNu/YsbbZvGPHLzRbjWZb1mzeWeIXms07IKxttggIoNkiIKxrtggIz83WIiAsa7YWAQE0WwSEdc0WAQE0W41mW9ZsERBAs0VAWNdsERBAs0VAWNdsERCem61HQFjWbD0CAmi2CAjrmi0CAmi2Gs22rNkiIIBmi4Cwrtki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LBCfqCcsEk89YZF46gmLxFNPWCReecIm5QmblCdsUp6wSXnCJuUJm5UnbFaesFl5wmbqCTvzzx/PdpNhP//Njr8jPqXxM4Gn9Ic//bt86hmL5VNPWSyfes5i+dSTFsunnrVQfqGetlg+9bzF8qknLpZPPXOxfO2pW7SnbtGeukV76hbtqVu0p27VnrpVe+pW7albtafu55nIa+VrT92qPXWr9tSt2lO3ak/dpj11m/bUbdpTt2lP3c8zPNfK1566TXvqNu2p27SnbtOeul176nbtqdu1p27XnrqfZ86tla89dbv21O3aU7drT92uPXWH9tQd2lOXmxmF5WtPXW5uFJavPXW52VFYvvbU5eZHYfnaU5ebIYXla09dbo4Ulq89dblZUli+9tTl5klh+dpTl5spheVrT11urhSWrz11udlSWL721OXmS2H52lOXmzGF5WtPXW7OFJavPHXPg5s1heUrT91LvvLUveQrT91LvvLUveQrT91LvvLUveQrT91LvvLUveRrT11u/hSWrz11uRlUWL721OXmUGH52lOXm0WF5WtPXW4eFZavPXW5mVRYvvbU5eZSYfnaU1eaTXXJ15660myqS7721JVmU13ytaeuNJvqkq89daXZVJd87akrzaa65GtPXWk21SVfe+pKs6ku+dpTV5pNdcnXnrrSbKpLvvbUlWZTXfK1p640m+qSrz11pdlUl3ztqSvNprrka09daTbVJV976kqzqS752lNXmk11ydeeutJsqku+9tSVZlNd8rWnrjSb6pKvPXWl2VSXfO2pK82muuRrT11pNtUlX3vqSrOpLvnaU1eaTXXJ15660myqS7721JVmU13ytaeuNJvqkq89daXZVJd87akrzaa65GtPXWk21SVfe+pKs6ku+dpTV5pNdcnXnrrSbKpLvvbUlWZTXfK1p640m+qSrz11pdlUl3ztqSvNprrkS0/dpM2mStpsqqTNpkrabKp0SE/dpM2mStpsqqTNpkrabKqkzaZK2myqpM2mStpsqqTNpkrabKqkzaZK2myqpM2mStpsqqTNpkrabKqkzaZK2myqpM2mStpsqqTNpkrkbKo8f+q4fjBv5HNP3TLHT/k1lRv591M3jZ//33I+jmf5/aj1Xz/uR2/P8lttP+W32sFa5yg/CzPHOP7449/En8Tif7zS968f/3hk8PnH1wRIP5d6/e8+/rLWNxirPdeajNaajdZajNZajdbajNbajdY69llrOv+41vnXtTIbob/973r+vtZ6s9atfNPzWquRb6pGvqka+aZq5JuqkW+qRr6pGvmmupFvgmvdyDchj1iNfFPbyjeBtRr5pmbkm5qRb2pGvqkZ+aZm5JuakW9qW503gbVu5JuQR+xGvqlv5ZvAWo18UzfyTd3IN3Uj39SNfFM38k3dyDd1o+ebxka+CXnEYeSbxla+CazVyDcNI980jHzTMPJNw8g3DSPfNIx80zR6vmlu5JuQR5xGvmlu5ZvAWqvR9Wrkm6aRb5pGvmka+aZp5JtOI990Gj3fdG7km5BHPI1807mVbwJrNfJNp5FvOo1802nkm04f35QPH9+UDx/flA+f55vysZFvAh4xH9XGN+VjK98E1urjm/Lh45vy4eOb8mHkm5KRb0pGvikZ+abk83xTThv5JuQRk5FvSlv5JrBWI9+UjHxTMvJN2cg3ZSPflI18UzbyTXmr8yaw1o18E/KI2cg35a18E1irkW8y4oVnI154NuKFZyNeeDbihWcjXng24oXnnXjhyCPuxAtHvsmIF5734oU/X69GvPBsxAvPRrzwbMQLz0a88GzEC89GvPC8Ey8cecSdeOHINxnxwvNevPDn69WIF56NeOHZiBeejXjh2YgXno144dmIF5534oUjj7gTLxz5JiNeeN6LF/58vRrxwrMRLzwb8cKzES88G/HCsxEvPBvxwvNOvHDkEXfihSPfZMQLz3vxwp+vVyNeeDbihWcjXng24oVnI154NuKFZyNeeN6JF4484k68cOSbjHjheS9eOLheq9FajXyTES88G/HCsxEvPBvxwrMRLzzvxAtHHnEnXjjyTUa88LwXLxxcr0a+yYgXno144dmIF56NeOHFiBdejHjhZSdeOPCIZSdeOPBN5ahGa/XxTcWIF16MeOHFiBdejHjhxYgXXox44cWIF1524oUjj7gTLxz5JiNeeNmLFw6uVyPfZMQLL0a88GLECy9GvPBixAsvRrzwshMvHHnEnXjhyDcZ8cLLXrxwcL0a+SYjXngx4oUXI154MeKFFyNeeDHihZedeOHII+7EC0e+yYgXXvbihYPr1cg3GfHCixEvvBjxwosRL7wY8cKLES+87MQLRx5xJ1448k1GvPCyFy/8+Xo14oUXI154MeKFFyNeeDHihRcjXngx4oWXnXjhyCPuxAtHvsmIF1724oU/X69GvPBixAsvRrzwYsQLL0a88GLECy9GvPCyEy8cecSdeOHINxnxwstevPDn69WIF16MeOHFiBdejHjhxYgXXox44cWIF1524oUjj7gTLxz5JiNeeNmLF/58vRrxwosRL7wY8cKLES+8GPHCixEvvBjxwstOvHDkEXfihSPfZMQLL3vxwsH1Wo3WauSbjHjhxYgXXox44cWIF16NeOF1J1448Ih1J1448E3ViBdej2p0vfr4pmrEC69GvPBqxAuvRrzwasQLr0a88LoTLxx5xJ144cg3GfHC6168cHC9GvkmI154NeKFVyNeeDXihVcjXng14oXXnXjhyCPuxAtHvsmIF1734oWD69XINxnxwqsRL7wa8cKrES+8GvHCqxEvvO7EC0cecSdeOPJNRrzwuhcvHFyvRr7JiBdejXjh1YgXXo144dWIF16NeOF1J1448og78cKRbzLihde9eOHgejXyTUa88GrEC69GvPBqxAuvRrzwasQLrzvxwpFH3IkXjnyTES+87sULf75ejXjh1YgXXo144dWIF16NeOHViBdejXjhdSdeOPKIO/HCkW8y4oXXvXjhz9erES+8GvHCqxEvvBrxwqsRL7wa8cKrES+87sQLRx5xJ1448k1GvPC6Fy/8+Xo14oVXI154NeKFVyNeeDXihVcjXng14oXXnXjhyCPuxAtHvsmIF1734oU/X69GvPBqxAuvRrzwasQLr0a88GrEC69GvPC2Ey8ceMS2Ey8c+KZmxAtve/HCwfVajdbq45uaES+8GfHCmxEvvBnxwpsRL7ztxAtHHnEnXjjyTUa88LYXLxxcr0a+yYgX3ox44c2IF96MeOHNiBfejHjhbSdeOPKIO/HCkW8y4oW3vXjh4Ho18k1GvPBmxAtvRrzwZsQLb0a88GbEC2878cKRR9yJF458kxEvvO3FCwfXq5FvMuKFNyNeeDPihTcjXngz4oU3I15424kXjjziTrxw5JuMeOFtL144uF6NfJMRL7wZ8cKbES+8GfHCmxEvvBnxwttOvHDkEXfihSPfZMQLb3vxwsH1auSbjHjhzYgX3ox44c2IF96MeOHNiBfeduKFI4+4Ey8c+SYjXnjbixf+fL0a8cKbES+8GfHCmxEvvBnxwpsRL7wZ8cLbTrxw5BF34oUj32TEC2978cKfr1cjXngz4oU3I154M+KFNyNeeDPihTcjXnjbiReOPOJOvHDkm4x44W0vXvjz9WrEC29GvPBmxAtvRrzwZsQLb0a88GbEC2878cKBR+w78cKBb+pGvPC+Fy/88XrtRrzwS6fRWn18UzfihXcjXng34oV3I15434kXjjziTrxw5JuMeOF9L144uF6r0VqNfJMRL7wb8cK7ES+8G/HCuxEvvO/EC0cecSdeOPJNRrzwvhcvHFyvRr7JiBfejXjh3YgX3o144d2IF96NeOF9J1448og78cKRbzLihfe9eOHgejXyTUa88G7EC+9GvPBuxAvvRrzwbsQL7zvxwpFH3IkXjnyTES+878ULB9erkW8y4oV3I154N+KFdyNeeDfihXcjXnjfiReOPOJOvHDkm4x44X0vXji4Xo18kxEvvBvxwrsRL7wb8cK7ES+8G/HC+068cOQRd+KFI99kxAvve/HCwfVq5JuMeOHdiBfejXjh3YgX3o144d2IF9534oUjj7gTLxz5JiNeeN+LF/58vRrxwrsRL7wb8cK7ES+8G/HCuxEvvBvxwvtOvHDkEXfihSPfZMQL73vxwp+vVyNeeDfihXcjXng34oV3I154N+KFdyNeeN+JF4484k68cOCbhhEvfOzFC3+8XocRL3wY8cLHUY3W6uObhhEvfBjxwocRL3zsxAsHHnHsxAtHvsmIFz724oU/X69GvPBhxAsfRrzwYcQLH0a88GHECx9GvPCxEy8cecSdeOHINxnxwsdevHBwvVajtRr5JiNe+DDihQ8jXvgw4oUPI1742IkXjjziTrxw5JuMeOFjL144uF6NfJMRL3wY8cKHES98GPHChxEvfBjxwsdOvHDkEXfihSPfZMQLH3vxwsH1auSbjHjhw4gXPox44cOIFz6MeOHDiBc+duKFI4+4Ey8c+SYjXvjYixcOrlcj32TECx9GvPBhxAsfRrzwYcQLH0a88LETLxx5xJ144cg3GfHCx168cHC9GvkmI174MOKFDyNe+DDihQ8jXvgw4oWPnXjhyCPuxAtHvsmIFz724oWD69XINxnxwocRL3wY8cKHES98GPHChxEvfOzEC0cecSdeOPJNRrzwsRcv/Pl6NeKFDyNe+DDihQ8jXvgw4oUPI174MOKFj5144cgj7sQLR77JiBc+9+KFP16v04gXPo144dOIFz6ParRWH980jXjh04gXPnfihQOPOHfihSPfZMQLn3vxwp+vVyNe+DTihU8jXvg04oVPI174NOKFTyNe+NyJF4484k68cOSbjHjhcy9e+PP1asQLn0a88GnEC59GvPBpxAufRrzwacQLnzvxwpFH3IkXjnyTES987sULB9drNVqrkW8y4oVPI174NOKFTyNe+DTihc+deOHII+7EC0e+yYgXPvfihYPr1cg3GfHCpxEvfBrxwqcRL3wa8cKnES987sQLRx5xJ1448k1GvPC5Fy8cXK9GvsmIFz6NeOHTiBc+jXjh04gXPo144XMnXjjyiDvxwpFvMuKFz7144eB6NfJNRrzwacQLn0a88GnEC59GvPBpxAufO/HCkUfciReOfJMRL3zuxQsH16uRbzLihU8jXvg04oVPI174NOKFTyNe+NyJF4484k68cOSbjHjhcy9eOLhejXyTES98GvHCpxEvfBrxwqcRL3wa8cLnTrxw5BF34oUj32TEC5978cIfr9fTiBd+GvHCTyNe+GnECz+ParRWH990GvHCz5144cAjnjvxwoFvOo144edevPDn69WIF34a8cJPI174acQLP4144acRL/w04oWfO/HCkUfciReOfJMRL/zcixf+fL0a8cJPI174acQLP4144acRL/w04oWfRrzwcydeOPKIO/HCkW8y4oWfe/HCn69XI174acQLP4144acRL/w04oWfRrzw04gXfu7EC0cecSdeOPJNRrzwcy9eOLheq9FajXyTES/8NOKFn0a88NOIF34a8cLPnXjhyCPuxAtHvsmIF37uxQsH16uRbzLihZ9GvPDTiBd+GvHCTyNe+GnECz934oUjj7gTLxz5JiNe+LkXLxxcr0a+yYgXfhrxwk8jXvhpxAs/jXjhpxEv/NyJF4484k68cOSbjHjh5168cHC9GvkmI174acQLP4144acRL/w04oWfRrzwcydeOPKIO/HCkW8y4oWfe/HCwfVq5JuMeOGnES/8NOKFn0a88NOIF34a8cLPnXjhyCPuxAtHvsmIF37uxQsH16uNb0rH4QMM/7FYG+f0Y7E21unHYm2804/FVqfF2jzl9GOxNp9b+bFYG//0Y7E24PAfi3VyUD7o8B+LdXJQPvDwH4t1clA++PAfi3VyUD4A8R+Ltfnyyo/FOjkoH4b4tdi9IOLgmvWhiP9YrJOD8uGI/1hs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mp2+BrW6NOGG35Ym3PDb0oQbfluaGqV5V5pww29LE274bWnCDb8tTbjht6UJN/yuNDt92Wt1acINvy1NuOG3pQk3/LY0NUrzrjThht+WJtzw29KEG35bmnDDb0sTbvhdaXb6Stvq0oQbfluacMNvSxNu+G1papTmXWnCDb8tTbjht6UJN/y2NOGG35Ym3PC70sS36N6XJtzw29KEG35bmnDDb0tTozTvShNu+G1pwg2/LU244belCTf8tjThht+VJr5F97404Ybflibc8NvShBt+W5oapXlXmnDDb0sTbvhtacINvy1NuOG3pQk3/K408S2696UJN/y2NOGG35Ym3PDb0tQozbvShBt+W5pww29LE274bWnCDb8tTbjhd6WJb9G9L0244belCTf8tjThht+WpkZp3pUm3PDb0oQbfluacMNvSxNu+G1pwg2/K018i+59acINvy1NuOG3pQk3/LY0NUrzrjThht+WJtzw29KEG35bmnDDb0sTbvhNaVJ8i+59acINvy1NuOG3pQk3/LY0NUrzrjThht+WJtzw29KEG35bmnDDb0sTbvhdaeJbdO9LE274bWnCDb8tTbjht6WpUZp3pQk3/LY04Ybflibc8NvShBt+W5pww+9KE9+ie1+acMNvSxNu+G1pwg2/LU2N0rwrTbjht6UJN/y2NOGG35Ym3PDb0oQbflea+Bbd+9KEG35bmnDDb0sTbvhtaWqU5l1pwg2/LU244belCTf8tjThht+WJtzwu9LEt+jelybc8NvShBt+W5pww29LU6M070oTbvhtacINvy1NuOG3pQk3/LY04YbflSa+Rfe+NOGG35Ym3PDb0oQbfluaGqV5V5pww29LE274bWnCDb8tTbjht6UJN/yuNPEtuvelCTf8tjThht+WJtzw29LUKM270oQbfluacMNvSxNu+G1pwg2/LU244XeliW/R/V/tvcuuJLuSHfgvPb4Dvh/f0gNBqhaEAgoqoSQ10AP9e3ueneEReTctGMljSS66r8nFznODYWstN9Ie4SRlaZgNi9IwGxalYTYsShMojSQNs2FRGmbDojTMhkVpmA2L0jAblqThXXSyNMyGRWmYDYvSMBsWpQmURpKG2bAoDbNhURpmw6I0zIZFaZgNS9LwLjpZGmbDojTMhkVpmA2L0gRKI0nDbFiUhtmwKA2zYVEaZsOiNMyG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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"7":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"62":{"source":"use jwt::JWT;\n// Maximum length for the partial data after SHA256 processing\nglobal MAX_PARTIAL_DATA_LENGTH: u32 = 256;\n\n// Main function of the circuit that proves a user is within vicinity of a landmark\n// while verifying the proof request comes from an authorized app via JWT verification\nfn main(\n    // Private inputs: User's location coordinates (scaled and offset to positive integers)\n    // Formula: Math.round((actual_coordinate + 90) * 1e6)\n    user_lat: Field, // User's latitude as a positive integer (actual_lat + 90) * 1e6\n    user_lon: Field, // User's longitude as a positive integer (actual_lon + 90) * 1e6\n    // Public inputs: Landmark location and maximum allowed distance\n    landmark_lat: pub Field, // Landmark's latitude (scaled and offset like user coordinates)\n    landmark_lon: pub Field, // Landmark's longitude (scaled and offset like user coordinates)\n    max_distance: pub Field, // Maximum allowed squared distance between user and landmark\n    // JWT verification parameters\n    partial_data: BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH>, // Remaining data after partial SHA256\n    partial_hash: [u32; 8], // First part of SHA256 hash (8 limbs of 32 bits each)\n    full_data_length: u32, // Total length of the JWT data before partial hashing\n    base64_decode_offset: u32, // Index to start base64 decoding (should be 1, 2, or 3 for partial SHA)\n    // RSA signature verification parameters\n    pubkey_modulus_limbs: pub [Field; 18], // RSA public key modulus in 18 limbs\n    redc_params_limbs: [Field; 18], // Montgomery reduction parameters for bignum operations\n    signature_limbs: [Field; 18], // RSA signature of the JWT in 18 limbs\n) {\n    // Initialize JWT verification with partial hash to optimize circuit constraints\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    // Verify JWT signature is valid\n    jwt.verify();\n\n    // Verify JWT was issued by the authorized \"vicinity\" app\n    // This prevents fake proofs from unauthorized applications\n    jwt.assert_claim_string(\"sub\".as_bytes(), BoundedVec::<u8, 8>::from_array(\"vicinity\".as_bytes()));\n\n    // Calculate the differences in scaled coordinates\n    let delta_lat = user_lat - landmark_lat;\n    let delta_lon = user_lon - landmark_lon;\n\n    // Compute squared differences for distance calculation\n    // Using squared distances avoids having to compute square roots\n    let delta_lat_sq = delta_lat * delta_lat;\n    let delta_lon_sq = delta_lon * delta_lon;\n\n    // Sum of squared differences approximates squared distance\n    // This works because coordinates are scaled uniformly (by 1e6)\n    let sum_squares = delta_lat_sq + delta_lon_sq;\n\n    // Assert that squared distance is within allowed threshold\n    // The threshold max_distance should be scaled appropriately for the coordinate scaling\n    assert(sum_squares as i64 <= max_distance as i64, \"User is too far from the landmark\");\n}\n","path":"/Users/satyam/projects/aztec-projects/noir-react-native-starter/circuits/vicinity/src/main.nr"},"63":{"source":"use base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse rsa::{rsa::verify_sha256_pkcs1v15, types::RBN2048};\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\nuse zkemail::partial_hash::partial_sha256_var_end;\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [Field; 18],\n    redc_params_limbs: [Field; 18],\n    signature_limbs: [Field; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [Field; 18],\n        redc_params_limbs: [Field; 18],\n        signature_limbs: [Field; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [Field; 18],\n        redc_params_limbs: [Field; 18],\n        signature_limbs: [Field; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature: RBN2048 = RuntimeBigNum::from_array(params, self.signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle: SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle: SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n","path":"/Users/satyam/nargo/github.com/saleel/noir-jwt/main/src/lib.nr"},"65":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let r = unsafe {\n        //@safety r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n        __boundary_check(limit)\n    };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/satyam/nargo/github.com/noir-lang/noir_base64/v0.4.0/src/boundary_check.nr"},"66":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[input_byte]\n                } else {\n                    BASE64_DECODE_BE_TABLE[input_byte]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[input_byte]\n            } else {\n                BASE64_DECODE_BE_TABLE[input_byte]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        unsafe {\n            //@safety get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n            // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    assert_eq(\n        has_first_padding_byte_claim,\n        has_second_padding_byte_claim * has_first_padding_byte_claim,\n        \"if first byte contains padding so must the second\",\n    );\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/Users/satyam/nargo/github.com/noir-lang/noir_base64/v0.4.0/src/decoder.nr"},"103":{"source":"use crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_120: Field = 0x1000000000000000000000000000000;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> Field {\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0]\n    } else if N == 2 {\n        validate_in_range::<N, MOD_BITS>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120 + limbs[2] * TWO_POW_120 * TWO_POW_120\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [Field; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result = unsafe { __from_field::<N>(field) };\n\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        let TWO_POW_120 = 0x1000000000000000000000000000000;\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let field_val = if N < 2 {\n            result[0]\n        } else if N == 2 {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120\n        } else {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120 + result[2] * TWO_POW_120 * TWO_POW_120\n        };\n        assert(field_val == field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120;\n        r *= TWO_POW_120;\n        modulus_mod_n *= TWO_POW_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += params.modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [Field; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += borrow_flags[0] as Field * TWO_POW_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * TWO_POW_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    validate_in_range::<_, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb =\n            modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * TWO_POW_120);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n                + (borrow_flags[i] as Field * TWO_POW_120);\n            assert(result_limb == 0);\n        }\n        let result_limb =\n            modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [Field; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb =\n            lhs[0] + rhs[0] - subtrahend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] + rhs[N - 1] - subtrahend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [Field; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] - rhs[N - 1] + addend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/Users/satyam/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/constrained_ops.nr"},"104":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/satyam/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/expressions.nr"},"106":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [Field; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = val[i].to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = val[N - 1].to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/Users/satyam/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/serialization.nr"},"107":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [Field; N] {\n    // cast the field to a u60 representation\n    let res_u60: U60Repr<N, 2> = U60Repr::from_field(field);\n    let result: [Field; N] = U60Repr::into(res_u60);\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = From::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = From::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let b_u60: U60Repr<N, 2> = From::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                let idx = (i - 1) / 2;\n                carry_flags[idx] = carry as bool;\n                borrow_flags[idx] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quirky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target.shr1();\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/Users/satyam/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/unconstrained_helpers.nr"},"108":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut temporaries: [[Field; N]; M] = std::mem::zeroed();\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[Field; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n","path":"/Users/satyam/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/unconstrained_ops.nr"},"110":{"source":"use crate::utils::u60_representation::U60Repr;\n\npub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [Field; N],\n\n    // @brief modulus but represented in a U60Repr form\n    pub modulus_u60: U60Repr<N, 2>,\n    pub modulus_u60_x4: U60Repr<N, 4>,\n\n    // @brief double_modulus: used when performing negations and subtractions\n    pub double_modulus: [Field; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [Field; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [Field; N],\n        redc_param: [Field; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            modulus_u60: U60Repr::from(modulus),\n            modulus_u60_x4: U60Repr::from(modulus),\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.modulus_u60 == other.modulus_u60)\n            & (self.modulus_u60_x4 == other.modulus_u60_x4)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [Field; N]) -> [Field; N] {\n    let TWO_POW_120: Field = 0x1000000000000000000000000000000;\n    let m: U60Repr<N, 2> = U60Repr::from(modulus);\n    let mut result: [Field; N] = U60Repr::into(m + m);\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/satyam/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/params.nr"},"111":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [Field; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\npub(crate) trait RuntimeBigNumTrait<let N: u32, let MOD_BITS: u32>: Neg + Add + Sub + Mul + Div + Eq {\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self;\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self;\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self;\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    fn modulus(self) -> Self;\n    fn modulus_bits() -> u32;\n    fn num_limbs() -> u32;\n    // pub fn get(self) -> [Field];\n    fn get_limbs(self) -> [Field; N];\n    fn get_limb(self, idx: u32) -> Field;\n    fn set_limb(&mut self, idx: u32, value: Field);\n\n    unconstrained fn __eq(self, other: Self) -> bool;\n    unconstrained fn __is_zero(self) -> bool;\n\n    // unconstrained\n    fn __neg(self) -> Self;\n    // unconstrained\n    fn __add(self, other: Self) -> Self;\n    // unconstrained\n    fn __sub(self, other: Self) -> Self;\n    // unconstrained\n    fn __mul(self, other: Self) -> Self;\n    // unconstrained\n    fn __div(self, other: Self) -> Self;\n    // unconstrained\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    // unconstrained\n    fn __invmod(self) -> Self;\n    // unconstrained\n    fn __pow(self, exponent: Self) -> Self;\n\n    // unconstrained\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M];\n    unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    // unconstrained\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    );\n\n    fn eq(lhs: Self, rhs: Self) -> bool {\n        lhs == rhs\n    }\n    fn assert_is_not_equal(self, other: Self);\n    fn validate_in_field(self);\n    fn validate_in_range(self);\n    // pub fn validate_gt(self, lhs: Self, rhs: Self);\n\n    fn udiv_mod(numerator: Self, divisor: Self) -> (Self, Self);\n    fn udiv(numerator: Self, divisor: Self) -> Self;\n    fn umod(numerator: Self, divisor: Self) -> Self;\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n    fn is_zero(self) -> bool;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNumTrait<N, MOD_BITS> for RuntimeBigNum<N, MOD_BITS> {\n\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [Field; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::new(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    fn get_limbs(self) -> [Field; N] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/Users/satyam/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/runtime_bignum.nr"},"118":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\npub(crate) global TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n//fields to u60rep conversion\n// field elements are 254 bits\n// so there will be 5 limbs\npub(crate) unconstrained fn field_to_u60rep(mut x: Field) -> (u64, u64, u64, u64, u64) {\n    // get the first 60 bits by casting to u64 and then taking the lower 60 bits\n    // we use the fact that this casting drops everything above 64 bits\n    let x_first_u64 = (x as u64);\n    let first: u64 = x_first_u64 % TWO_POW_60;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_60 as Field);\n    let x_second_u64 = (x as u64);\n    let second = x_second_u64 % TWO_POW_60;\n    x = (x - (second as Field)) / (TWO_POW_60 as Field);\n    let x_third_u64 = (x as u64);\n    let third = x_third_u64 % TWO_POW_60;\n    x = (x - (third as Field)) / (TWO_POW_60 as Field);\n    let x_fourth_u64 = (x as u64);\n    let fourth = x_fourth_u64 % TWO_POW_60;\n    x = (x - (fourth as Field)) / (TWO_POW_60 as Field);\n    let x_fifth_u64 = (x as u64);\n    let fifth = x_fifth_u64 % TWO_POW_60;\n    (first, second, third, fourth, fifth)\n}\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\nunconstrained fn __split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\npub fn split_60_bits(x: Field) -> (u64, u64) {\n    // We assert that the two returned limbs fit within 60 bits each\n    // and reconstruct `x` when added together.\n    let (lo, hi) = unsafe { __split_60_bits(x) };\n    if !std::runtime::is_unconstrained() {\n        let lo_field = lo as Field;\n        let hi_field = hi as Field;\n        lo_field.assert_max_bit_size::<60>();\n        hi_field.assert_max_bit_size::<60>();\n        assert_eq(lo_field + (TWO_POW_60 as Field) * hi_field, x);\n    }\n\n    (lo, hi)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/satyam/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/split_bits.nr"},"119":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\nuse crate::utils::split_bits::{field_to_u60rep, TWO_POW_60};\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..N {\n            let (lo, hi) = split_bits::split_60_bits(input[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\n// impl<let N: u32, let NumSegments: u32> std::convert::From<Field> for U60Repr<N, NumSegments> {\n//     fn from(input: Field) -> Self {\n//        let (low, mid, high) =  unsafe { field_to_u60rep(input) } ;\n//         let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n//         let N_u60: u32 = N * NumSegments;\n//         assert(N_u60 >=1, \"N must be at least 1\");\n//         if N_u60 == 1 {\n//             assert((mid ==0) & (high == 0), \"input field is too large to fit in a single limb\");\n//             result.limbs[0] = low;\n//         }\n//         else if N_u60 == 2{\n//             assert(high == 0, \"input field is too large to fit in two limbs\");\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//         }else{\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//             result.limbs[2] = high;\n//         }\n//         result\n//     }\n// }\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) fn new<let NumFieldSegments: u32>(x: [Field; N * NumFieldSegments]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn from_field(input: Field) -> Self {\n        let (first, second, third, fourth, fifth) = field_to_u60rep(input);\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        let N_u60: u32 = N * NumSegments;\n        assert(N_u60 >= 1, \"N must be at least 1\");\n        if N_u60 == 1 {\n            assert(\n                (second == 0) & (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in a single limb\",\n            );\n            result.limbs[0] = first;\n        } else if N_u60 == 2 {\n            assert(\n                (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in two limbs\",\n            );\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n        } else if N_u60 == 3 {\n            assert((fourth == 0) & (fifth == 0), \"input field is too large to fit in three limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n        } else if N_u60 == 4 {\n            assert((fifth == 0), \"input field is too large to fit in four limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n        } else {\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n            result.limbs[4] = fifth;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        for i in 0..(N * NumSegments / 2) {\n            result[i] =\n                x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * TWO_POW_60 as Field);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            let idx = (N * NumSegments) - 1 - i;\n            if (b.limbs[idx] == self.limbs[idx]) {\n                continue;\n            }\n\n            result = b.limbs[idx] < self.limbs[idx];\n            early_exit = true;\n            break;\n        }\n        if early_exit {\n            result\n        } else {\n            self.limbs[0] == b.limbs[0]\n        }\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift = (60 - limb_shift) as u8;\n        let mask: u64 = (((1 as u64) << limb_shift) - 1) << remainder_shift;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = value >> limb_shift;\n            let remainder: u64 = (value << remainder_shift) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << limb_shift) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << limb_shift) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/Users/satyam/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/u60_representation.nr"},"130":{"source":"use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_1024() {\n    // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world! test#123\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170,\n                193, 96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n            ],\n    );\n\n    let params: BigNumParams<9, 1024> = BigNumParams::new(\n        false,\n        [\n            0xab238ad9cb37979a43aefbf10be8fb,\n            0x31347febe45fe8c2dac1dd30900704,\n            0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n            0x5eac6390f7873fe97ff9bb14a173ea,\n            0xbc41f700c91fd733a2c63177bbdbd4,\n            0x41442bd58769a3595b659a2ec9c6be,\n            0x4ddc91395f330382aa2e2d3fbe147,\n            0x3d008ff255a0bc71c7887f5728ba1,\n            0xb640c3a8f511c64e,\n        ],\n        [\n            0x5d53d2634c6a0918266043968ce263,\n            0x5dd4be3dce0323a492ee9340aec4db,\n            0xf82d0e2e5c8319f01a460c72c01854,\n            0x236e6fc6e62e8a1d522acda5fb3892,\n            0xdaf755619d66e580901aa224d03174,\n            0x8366291616480e7e1f202dbcedda87,\n            0x40ba1202537d1e94561ccc05265586,\n            0x69b993d857ba89ea5de9822aeb4b93,\n            0x167968c0000761a273,\n        ],\n    );\n\n    let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xc3850e84ea02da3f028ff422f4d6a9,\n            0x9761f0bd9021f76d45c60df0670a19,\n            0xc1ede421a43607ab623ed4d5a17fc8,\n            0x86197b4315206f4d53200b42555831,\n            0xe95783b69db28c26a83706f39d04cd,\n            0x18b178dc1a9ec76fb22b57e4dfa703,\n            0xdd0e19cd5a09ab48e7af4d0e3470e3,\n            0x10004dfab1cf91304e80e6baa4dfc7,\n            0x241c3fd77b90adef,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048() {\n    // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131,\n                166, 79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n            0xbfb937fc4d3cf02cc0af780f3cab44,\n            0xd20637ef7adcf5d238ee87bccc9bca,\n            0xb9db4f2663108e2f8b673f7612ae8b,\n            0x85f894ef669b36bfd3d86b0a28873,\n            0xdcc70e1884e38b8229cce3b884121d,\n            0x35488d1138e0b03e1676f7f5d8a5b3,\n            0xe1a97820e7dcbb4eab35c9b71bb273,\n            0x97d19eb3c63249ddbfcff915863f54,\n            0x3a78c7af6da0f6af0d67b1ca4b6065,\n            0xd7a3c433c020f624821e5e678c7d69,\n            0x52d5b53240feae82ffea3d2a3d9b09,\n            0xb8aad5e19e2163f68997c6fdd71906,\n            0x5db432d06e8b0bf59511100c7894e2,\n            0xadc0bbc4c54da10d1cc88438ea3127,\n            0xece1cf6a1501109cd2734d5893c8d9,\n            0x7196b90acdf06c31b1288064fd0c27,\n            0xc8,\n        ],\n        [\n            0x1b1deccf4dbde852c34a5d6908a0f,\n            0xbc9e5bdab22f023fbcca58692bccf5,\n            0x1f65439685623e45396ff55751c3bf,\n            0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n            0x5ca2e8e3048243c16c708a8030ab0d,\n            0x30079bfeb1fa51e5501581173ca19c,\n            0xff8d5f6bea485fdcc2716327f69ab4,\n            0x36b599d81589416b5b5f037986b999,\n            0x75612e34a4ff29f0a19a7823512f58,\n            0x288b6897929b54c3b26a5faa07c00f,\n            0x4b5675fa13ab7444f1f047d3eb1bbe,\n            0x6ba0ac610ef9f267ab30fe25bb1c84,\n            0xa386b48ee03168d5cea3ecb9dc901f,\n            0xacf1a01f7dba44e050c976142fb1f6,\n            0x97a63b5cb7efc60d3502946aec63cf,\n            0x12cc1d5cab10a1e9e2398d29b9e3ef,\n            0x4635cf25c66e76bba8034df46204fb,\n            0x146f,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xad29e07d16a278de49a371b9760a27,\n            0x86311920cc0e17a3c20cdff4c56dbb,\n            0x863556c6c5247dd83668dd825716ae,\n            0xc247c960945f4485b46c33b87425ca,\n            0x7326463c5c4cd5b08e21b938d9ed9a,\n            0x4f89fe0c82da08a0259eddb34d0da1,\n            0x43a74e76d4e1bd2666f1591889af0d,\n            0x240f7b80f0ff29f4253ee3019f832d,\n            0xc6edd131fbaaf725fd423dac52b362,\n            0x85f9732679242163e8afff44f6104d,\n            0xd3c3bbcb1757013fd6fb80f31dd9a6,\n            0x9008633f15df440e6df6d21ee585a2,\n            0x324df3425ed256e283be5b6b761741,\n            0xc60c1302929bd0e07caa4aeff4e8fd,\n            0x600d804ff13ba8d0e1bc9508714212,\n            0x50f7e75e5751d7edd61167027926be,\n            0x0db41d39442023e1420a8a84fe81d9,\n            0xab,\n        ],\n    };\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n    // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132,\n                239, 227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0xe40ee47801326543c8e84b85d567c1,\n            0x5b54ea87f0ce29de1995697b0696fd,\n            0x457078f8fdce68b437cac0970b2452,\n            0x473ec776fee3731b6ab06e35875ddc,\n            0x62dedd594e5f12c80c3ccb5791a6cd,\n            0xecb934b9d8272c5e3a418145345499,\n            0xd1af643b3d785470ed0c6cd633f706,\n            0xb58a57b9e96eccbdfc7c17f0333d4,\n            0x2ebd34b5039fc596504927c282c60d,\n            0x3a44928a74f25fc1043bb37ce4dfa8,\n            0x91448459f9617fac33a2816162ac9e,\n            0x70cb910d9f3e1a78864640ec6c8240,\n            0x9aed33f6b31f1c9de67248a98c180,\n            0x7f1416e032c79488c94b311e87bd9c,\n            0x7191b4ebb1b3fffa949fa48ed01e5,\n            0x350a75cbaeca6bfdd71ca83cdbcae9,\n            0xfb1d274fa207457c6814d42c09f9cf,\n            0xd4,\n        ],\n        [\n            0x803bf4d38110a7d37fdd05f590dee9,\n            0xa68d317c933f37cab5ab4e7c00a3b9,\n            0x476a05a536bf5f2aa1b8850146cba7,\n            0xca297ea8b5528d91d4836ff27c30ab,\n            0x75cf2eaab76eefa12bbd570f1aea9f,\n            0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n            0xd497db1f6ebe83decacaa647fabea6,\n            0x686b27ca330e25e7a7cf197f6433ef,\n            0xfde04d2225c8308b07580af0058a0f,\n            0xa29fb69777c0e916976243b2b09855,\n            0xf983592285852e7e1c2cb3ae968323,\n            0x673608017f9f5acf67a01b73728d70,\n            0xeeff82521c0bc432a05f4b7444fac0,\n            0x85a89c4d229f60aaa3aa7ac7dac1e2,\n            0xcfecff93bc9fbfe0d6dff6091f2db8,\n            0xf20f047dcb224b4447bd098c07f8c2,\n            0x554bb53cadeb3eaab911a189f90227,\n            0x133b,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xa250eff812c63eaaeaa3f04641c05f,\n            0xecc09613cb8b289c1f37c8f92e6a05,\n            0x2c0a0510058360c07af65d46f594fd,\n            0x943d67513363d3de430c94a1dafe7c,\n            0x511ec8e9b10bc6c6ff0d6c232ccf92,\n            0x50ffd07b3c093b3f5fc027de847731,\n            0xc268e1489449943fdafdf89ff168c3,\n            0x0b8b7f9f49b492f78fda58d252f23a,\n            0x491c6c4ef836a6a8730b7bf81e865e,\n            0x8746c75fb079d014e419543f56d7f0,\n            0x65804c417d6168a8bc0025d255cebf,\n            0xf695e91b77890b8e3fd775fa56e627,\n            0x5e90001c0218550f4083ae28025a2f,\n            0x526bd4eff34f25f62a698f0470e0a6,\n            0x7f224306a7d9daf536b1559434c6c6,\n            0x88809f16fe1fcea3c87511d9319735,\n            0x7694685fee0bfab4a9196b92ec6f2e,\n            0xa7,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n}\n","path":"/Users/satyam/nargo/github.com/noir-lang/noir_rsa/v0.6.0/lib/src/rsa.nr"},"136":{"source":"mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine, lt_f};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: Field,\n        body_chunk_offset: Field,\n        num_full_chunks: Field,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: Field) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: Field) -> u8 {\n        self.body[idx as u32]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: Field,\n        starting_haystack_chunk: Field,\n        num_full_chunks: Field,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte as Field + (i as Field * 31) + j as Field;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate: Field = lt_f(i as Field, num_full_chunks) as Field;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as Field * (i as Field + starting_haystack_chunk)];\n            assert(predicate * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: Field = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: Field = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks =\n            lt_f(substring_length as Field, num_bytes_in_first_chunk as Field);\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks as Field * 31 + num_bytes_in_first_chunk as Field;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks as Field + chunk_index as Field + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index as Field;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: Field = chunk_offset as Field;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: Field = i as Field;\n            let predicate: Field = lt_f(i as Field, offset_to_first_needle_byte_in_chunk) as Field;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = (1 - predicate) * (idx - offset_to_first_needle_byte_in_chunk);\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index: Field =\n                starting_needle_byte_index_of_final_chunk as Field + i as Field;\n            let predicate = lt_f(lhs_index, substring_length as Field);\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as Field) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset: Field = chunk_index as Field + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk as Field,\n            body_chunk_offset,\n            num_full_chunks as Field,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n","path":"/Users/satyam/nargo/github.com/noir-lang/noir_string_search/v0.3.2/src/lib.nr"},"137":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub unconstrained fn get_lt_predicate_f(x: Field, y: Field) -> bool {\n    let a = x as u32;\n    let b = y as u32;\n    a < b\n}\n\npub fn lt_f(x: Field, y: Field) -> bool {\n    // Safety: As `x` and `y` are known to be valid `u32`s, this function reimplements the\n    // compiler's internal implementation of `lt`\n    unsafe {\n        let predicate = get_lt_predicate_f(x, y);\n        let delta = y as Field - x as Field;\n        let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta;\n        lt_parameter.assert_max_bit_size::<32>();\n\n        predicate\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/Users/satyam/nargo/github.com/noir-lang/noir_string_search/v0.3.2/src/utils.nr"},"144":{"source":"use crate::tests::test_inputs::PartialHash::DATA;\nuse std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L23\n// Convert 64-byte array to array of 16 u32s\npub fn msg_u8_to_u32(msg: [u8; BLOCK_SIZE]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L38\nunconstrained fn build_msg_block_iter<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L59\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32,\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE: u32 = 64;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L86-L116\n/**\n * Partially computes a SHA256 hash of a message but does not finalize\n * @notice can be used for post-partial hashing where client proves part of hash and relies on server to finish\n * \n *\n * @param N: the length of the message to hash.\n *  --- WARNING: N must be divisible by BLOCK_SIZE such that N % BLOCK_SIZE == 0 \n *      otherwise the remaining bytes will not be inputted when computing the initial hash\n * @param msg: the preimage to begin hashing\n * @return the intermediate hash state\n */\npub fn partial_sha256_var_start<let N: u32>(msg: [u8; N]) -> [u32; 8] {\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) & (msg_start < message_size) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L85\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the remaining preimage\n * @param real_message_size -= the total size of the preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u64,\n    real_message_size: u64,\n) -> [u8; 32] {\n    let message_size = message_size as u32; // noir stdlib uses u64\n    let real_message_size = real_message_size as u32; // noir stdlib uses u64\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !is_unconstrained() {\n        for i in 0..64 {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..64 {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, real_message_size) };\n\n    if !is_unconstrained() {\n        for i in 0..56 {\n            if i < msg_byte_ptr {\n                assert_eq(msg_block[i], last_block[i]);\n            } else {\n                assert_eq(msg_block[i], zero);\n            }\n        }\n\n        let len = 8 * real_message_size;\n        let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n        for i in 56..64 {\n            assert_eq(msg_block[i], len_bytes[i - 56]);\n        }\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n    message_size: u32,\n) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n#[test]\nfn test_partial_hash() {\n    let mut data0 = [0; 128];\n    for i in 0..data0.len() {\n        data0[i] = DATA[i];\n    }\n    let mut data1 = [0; 64];\n    for i in 0..data1.len() {\n        data1[i] = DATA[data0.len() + i];\n    }\n    let state = partial_sha256_var_start(data0);\n    let hash = partial_sha256_var_end(state, data1, data1.len() as u64, DATA.len() as u64);\n    let correct_hash = std::hash::sha256_var(DATA, DATA.len() as u64);\n    assert_eq(hash, correct_hash);\n}\n\n#[test]\nfn test_partial_hash_interstitial() {\n    let mut data0 = [0; 64];\n    let mut data1 = [0; 64];\n    let mut data2 = [0; 64];\n    for i in 0..data0.len() {\n        data0[i] = DATA[i];\n        data1[i] = DATA[64 + i];\n        data2[i] = DATA[128 + i];\n    }\n    let pre_hash = partial_sha256_var_start(data0);\n    let interstitial_hash = partial_sha256_var_interstitial(pre_hash, data1, data1.len());\n    let hash = partial_sha256_var_end(\n        interstitial_hash,\n        data2,\n        data2.len() as u64,\n        DATA.len() as u64,\n    );\n    let correct_hash = std::hash::sha256_var(DATA, DATA.len() as u64);\n    assert_eq(hash, correct_hash);\n}\n\n#[test]\nfn test_partial_hash_interstitial_var() {\n    let mut data0 = [0; 64];\n    let mut data1 = [0; 128]; // second block not used\n    let mut data2 = [0; 64];\n    for i in 0..data0.len() {\n        data0[i] = DATA[i];\n        data1[i] = DATA[64 + i];\n        data2[i] = DATA[128 + i];\n    }\n    let pre_hash = partial_sha256_var_start(data0);\n    let interstitial_hash = partial_sha256_var_interstitial(pre_hash, data1, 64);\n    let hash = partial_sha256_var_end(\n        interstitial_hash,\n        data2,\n        data2.len() as u64,\n        DATA.len() as u64,\n    );\n    let correct_hash = std::hash::sha256_var(DATA, DATA.len() as u64);\n    assert_eq(hash, correct_hash);\n}\n","path":"/Users/satyam/nargo/github.com/zkemail/zkemail.nr/v0.4.2/lib/src/partial_hash.nr"}},"names":["main"],"brillig_names":["build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","__split_60_bits","__mul","__compute_quadratic_expression_with_borrow_flags","extract_claim_unconstrained","__boundary_check","__validate_decoded","search","get_lt_predicate_f","directive_integer_quotient","directive_invert","directive_to_radix"]}